# 协议

## 作用

解决tcp传输中粘包和半包问题：数据在网络中通过二进制传输，传输过程中可能会拆包或合并，通过协议可以实现准确地断句

## 如何设计协议

### 为什么不用http

- 和http相比rpc更多的是负责应用间通信，性能要求更高
- http协议数据包大小相对请求数据本身大很多，还要加入很多无用的内容
- http协议属于无状态协议，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接

### 怎么设计

1. 协议头
2. 协议体

### 可扩展协议

- 定长协议头，添加参数会导致线上兼容问题

#### 为什么不放在协议体

- 协议体内容是经过序列化的，在某些场景下代价较高，如过期请求

# 序列化

## 为什么需要序列化

需要将传请求调用方传入的对象参数转化成能够在网络中传输的二进制数据

## 有哪些常用的序列化

### JDK原生

- **ObjectOutputStream**和**ObjectInputStream**实现
- 过程：
  - 在读取对象数据的时候，加入特殊的分隔符作为截断使用
  - 头部数据用来表明序列化协议，版本，用于高本本向后兼容
  - 对象数据包括类名，签名，数学名，属性类型，属性值
  - 存在对象引用，继承情况下就是递归遍历写对象

### JSON

- key-value格式，没有参数类型
- 问题：
  - JSON额外空间开销大
  - JSON没有类型，java强类型语言需要通过反射解决，性能不好

### Hessian

- 比JDK，JSON更加紧凑，性能更好，生成字节数据更小
- 问题
  - 对java一些常见对象类型不支持：Linked系列，Byte/Short反序列化成Integer

### Protobuf

- google的标准，使用时需要定义LDL，然后使用不同语言IDL编译器生成序列化工具类
- 优点
  - 体积小
  - IDL能清晰描述语意
  - 速度快，不需要反射获取类型
  - 兼容性好

### Kryo

- 底层依赖ASM库生成字节码，速度快，针对java语言
- 速度快，体积小，易用，支持自动深浅拷贝
- 直接通过对象到对象的深拷贝，不是对象到字节到对象的过程

## 如何选择序列化

- 性能，效率，空间开销，通用性和兼容性，安全性

## RPC框架使用注意哪些问题

- 对象构造过于复杂，关联聚合
- 对象过于庞大
- 使用框架不支持的类作为入参类
- 复杂的继承关系

# 动态代理

## 代理模式

- 代理模式 (Proxy Pattern) 也称委托模式 (Deletage Pattern)，属于结构型设计模式，也是一项基本的设计技巧。通常，代理模式用于处理两种问题：
  1. 控制对基础对象的访问
  2. 在访问基础对象时增加额外功能
- 分类
  - 静态代理
  - 动态代理

## 静态代理

- 为每个业务抽象一个接口并创建代理类
- 缺点
  - 重复代码多
  - 改动接口后代理类需要同步修改

## 动态代理

- 指在运行时确定的代理模式，因为代理类在编译前不存在，代理关系到运行时才确定，所以称为动态代理

## 对比

- 共同点
  - 不改变原有对象情况下，对基础对象进行访问控制和扩展
- 不同点
  - 静态代理存在重复性和脆弱性
  - 动态代理可以实现一个代理处理多个接口
  - 静态代理在编译期生成
  - 动态代理在运行时生成

## 实现方法

### JDK

- 局限：
  - 要求被代理类只能是接口，因为生成的代理类会继承Proxy类，java不支持多继承
  - 性能问题：通过反射调用，相比于直接编码调用，性能较低

### Javassist

- 能够操纵字节码，使用起来较为复杂
- 不需要通过反射，性能更好

### byte buddy

- spring，jackson都用到bytebuddy完成底层代理
- 基于ASM实现，提供易操作的api，生成代理类执行速度快

# 网络通信

## IO模型

### BIO

- 阻塞io
- 流程
  1. 应用发起IO系统调用后，进程被阻塞，转到内核空间处理
  2. 内核等待数据，之后将内核数据拷贝到用户内存中
  3. 整个IO处理完毕后返回进程，应用解除阻塞，恢复业务逻辑

### IO多路复用

- java NIO，redis nginx底层实现

1. 多个网络连接IO注册到一个select上，用户进程调用select后，整个进程被阻塞
2. 内核监视select负责的socket，当数据准备好后，select返回，此时用户进程再调用read，将数据从内核拷贝到用户进程

#### 优势

- 用户可以在一个线程内同时处理多个IO请求

### 为什么BIO和IO多路复用最常用

- 系统内核支持
- 编程语言支持

## 零拷贝

- 等待数据：等待网卡接收到数据后把数据写到内核
- 拷贝数据：内核获取数据后，将数据拷贝到用户进程

- 零拷贝：取消用户空间与内核空间之间的数据拷贝操作
- 解决：虚拟内存

### Netty中的零拷贝

- 在JVM上操作，偏向于数据操作优化

#### 怎么优化

- CompositeByteBuf：将多个ByteBuf合并一个逻辑上的ByteBuf，避免ByteBuf之间拷贝
- ByteBuf：支持slice操作，将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免内存拷贝
- wrap操作，将数据包装整ByteBuf，避免拷贝

#### 用户空间和内核空间拷贝

- DirectBuffers，使用堆外直接内存进行Scoket读写
- FileChannel.transferTo() 方法实现零拷贝，与linux的sendfile原理一致

# 服务发现

## 为什么需要服务发现

- 服务提供方以集群方式对外提供服务，集群里ip随时可能变化，需要一个中介来及时获取对应服务节点

## 为什么不用DNS

- 使用dns实现服务发现，把服务提供者节点被指在同一域名下，调用方可以通过DNS拿到一个IP
- 如果IP下线或者新增IP，dns无法做到及时更新
- 因为dns采取多级缓存机制且缓存时间较长，服务调用者不难及时感知服务节点变化
- 增加负载均衡设备，域名绑定到负载均衡设备上，通过dns找到负载均衡ip，由负载均衡做转发：不合适
  - 搭建负载均衡设备需要额外成本
  - 请求都经过负载均衡设备，多一次网络传输，浪费性能
  - 负载均衡添加删除需要手动，不够灵活

// TODO 消息zookeeper和消息总线

# 健康检测

- 让调用方实时感知节点状态变化

### 健康检测逻辑

- 健康，死亡，亚健康

# 负载均衡

### 什么是负载均衡

当一个服务节点无法支撑现有访问量时，会部署多个节点形成集群，通过负载均衡将请求分发给集群下的服务器，达到分担请求压力的目的

### 为什么不使用负载均衡器

1. 搭建负载均衡器需要额外成本
2. 所有流量都经过负载均衡设备，多经过一次网络传输，浪费性能
3. 负载均衡器添加删除节点需要手动添加
4. 不同服务可能需要不同的负载均衡策略，使用单一负载均衡设备无法满足该场景

### 如何实现

RPC客服端会与注册中心下发的所有服务节点建立长连接，每次发起RPC调用时，客户端通过配置负载均衡插件自主选择一个服务节点，发起RPC调用

### 如何设计自适应的负载均衡策略

1. 确定指标
2. 收集指标信息
3. 指标评分
4. 计算权重
